// @type: page
// @id: contact
// @title: Форма обратной связи
// @layout: public

// @field form_title: string = "Заголовок формы"
// @field form_fields[]: list[object] = "Поля формы"
// @field form_fields[].id: string = "ID поля"
// @field form_fields[].label: string = "Название поля"
// @field form_fields[].placeholder: string = "Подсказка"
// @field form_fields[].required: bool = "Обязательное"
// @field form_fields[].validation_message: string = "Сообщение при ошибке"
// @field form_fields[].type: select[string|email|text|number|phone|radio|select] = "Тип поля"
// @field form_fields[].pattern: string = "Паттерн" dependsOn=form_fields[].type:[phone]
// @field form_fields[].min: number = "Минимум" dependsOn=form_fields[].type:[number]
// @field form_fields[].max: number = "Максимум" dependsOn=form_fields[].type:[number]
// @field form_fields[].min_length: number = "Мин. длина" dependsOn=form_fields[].type:[string,text,email,phone]
// @field form_fields[].max_length: number = "Макс. длина" dependsOn=form_fields[].type:[string,text,email,phone]
// @field form_fields[].options[]: list[object] = "Варианты" dependsOn=form_fields[].type:[select,radio]
// @field form_fields[].options[].value: string = "Значение"
// @field form_fields[].options[].label: string = "Подпись"

// @field submit_text: string = "Текст кнопки отправки"
// @field success_message: text = "Сообщение об успешной отправке"

package pages

import (
	"fmt"
	"mobile-backend-boilerplate/internal/view/icons"
	"mobile-backend-boilerplate/internal/view/layouts"
	"mobile-backend-boilerplate/internal/view/partials"
	"mobile-backend-boilerplate/pkg/types"
	"strings"
)

type ContactPageProps struct {
	LayoutContent layouts.PublicLayoutProps
	PageContent   ContactPagePartialProps
	State         ContactFormState
}

type ContactPagePartialProps struct {
	FormTitle  string       `json:"form_title"`
	FormFields []FormFields `json:"form_fields"`
}

type FormFields struct {
	ID                string            `json:"id"`
	Label             string            `json:"label"`
	Placeholder       string            `json:"placeholder"`
	Required          types.BoolOrEmpty `json:"required"`
	ValidationMessage string            `json:"validation_message"`
	Type              string            `json:"type"`
	Pattern           string            `json:"pattern"`
	Min               types.IntOrEmpty  `json:"min"`
	Max               types.IntOrEmpty  `json:"max"`
	MinLength         types.IntOrEmpty  `json:"min_length"`
	MaxLength         types.IntOrEmpty  `json:"max_length"`
	Options           []Option          `json:"options"`
}

type Option struct {
	Value string `json:"value"`
	Label string `json:"label"`
}

type ContactFormState struct {
	Values  map[string]string
	Errors  map[string]string
	Success bool
}

type CustomType interface {
	types.IntOrEmpty | string
}

func NewContactFormState() *ContactFormState {
	return &ContactFormState{
		Values:  nil,
		Errors:  nil,
		Success: true,
	}
}

func setCorrectAttribute[T CustomType](attribute string, value T) string {
	switch v := any(value).(type) {
	case types.IntOrEmpty:
		if v.Valid && v.Value != 0 {
			return fmt.Sprintf("%s={%d}", attribute, v.Value)
		}
	case string:
		if v != "" {
			return fmt.Sprintf("%s=%v", attribute, value)
		}
	}

	return ""
}

func setShowClass(class string, show bool) string {
	if show {
		return strings.Join([]string{class, "show"}, " ")
	}
	return class
}

func setErrorClass(class string, err bool) string {
	if err {
		return strings.Join([]string{class, "error"}, " ")
	}
	return class
}

templ ContactPage(props ContactPageProps) {
	@layouts.PublicLayout(props.LayoutContent) {
		@ContactPagePartial() {
			@ContactPagePartialForm(props.PageContent, props.State)
		}
	}
}

templ ContactPageContent(props ContactPageProps) {
	@layouts.PublicLayoutPartial(props.LayoutContent) {
		@ContactPagePartial() {
			@ContactPagePartialForm(props.PageContent, props.State)
		}
	}
}

templ ContactPagePartial() {
	<style>
        .input-field.error,
        .textarea-field.error {
            border-color: var(--error);
        }

        .error-message {
            color: var(--error);
            font-size: var(--text-xs);
            margin-top: var(--space-xxs);
        }

        .radio-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: var(--space-sm);
            width: 100%;
        }

        .send,
        .loader,
        .success {
            display: none;
        }

        .send.show,
        .loader.show,
        .success.show {
            display: inline-block;
        }
    </style>
	@partials.Card(500) {
		{ children... }
	}
	<script>
		function handleSuccessTimeout(formEl) {
			const btn = formEl.querySelector(".btn");
			if (!btn) return;
			const sendIcon = btn.querySelector(".send");
			const successIcon = btn.querySelector(".success");

			if (successIcon.classList.contains("show")) {
				setTimeout(() => {
					sendIcon.classList.add("show");
					successIcon.classList.remove("show");
					btn.querySelector(".btn-text").textContent = "Отправить";
				}, 2000);
			}
		}
	</script>
}

templ RenderInputField(field FormFields, value string, hasError bool) {
	<input
		name={ field.ID }
		type={ field.Type }
		placeholder={ field.Placeholder }
		required={ field.Required.Value }
		value={ value }
		{ setCorrectAttribute("pattern", field.Pattern) }
		{ setCorrectAttribute("min", field.Min) }
		{ setCorrectAttribute("max", field.Max) }
		{ setCorrectAttribute("minLength", field.MinLength) }
		{ setCorrectAttribute("maxLength", field.MaxLength) }
		title={ field.ValidationMessage }
		class={ setErrorClass("input-field", hasError) }
	/>
}

templ RenderTextField(field FormFields, value string, hasError bool) {
	<textarea
		name={ field.ID }
		placeholder={ field.Placeholder }
		required={ field.Required.Value }
		{ setCorrectAttribute("pattern", field.Pattern) }
		{ setCorrectAttribute("min", field.Min) }
		{ setCorrectAttribute("max", field.Max) }
		{ setCorrectAttribute("minLength", field.MinLength) }
		{ setCorrectAttribute("maxLength", field.MaxLength) }
		class={ setErrorClass("textarea-field", hasError) }
	>
		{ value }
	</textarea>
}

templ RenderSelectField(field FormFields, value string, hasError bool) {
	<select name={ field.ID } required={ field.Required.Value } class={ setErrorClass("input-field", hasError) }>
		for _, opt := range field.Options {
			<option value={ opt.Value } selected={ value == opt.Value }>
				{ opt.Label }
			</option>
		}
	</select>
}

templ RenderRadioGroup(field FormFields, value string) {
	<div class="radio-group">
		for _, opt := range field.Options {
			<div>
				<input
					type="radio"
					name={ field.ID }
					id={ field.ID + "-" + opt.Value }
					value={ opt.Value }
					checked?={ value == opt.Value }
					required={ field.Required.Value }
				/>
				<label for={ field.ID + "-" + opt.Value }>{ opt.Label }</label>
			</div>
		}
	</div>
}

templ RenderFormFields(fields []FormFields, values, errors map[string]string) {
	for _, field := range fields {
		<div class="field-group">
			<label for={ field.ID }>
				{ field.Label }
				if field.Required.Value {
					<span class="required">*</span>
				}
			</label>
			switch field.Type {
				case "string", "email", "number", "phone":
					@RenderInputField(field, values[field.ID], errors[field.ID] != "")
				case "text":
					@RenderTextField(field, values[field.ID], errors[field.ID] != "")
				case "select":
					@RenderSelectField(field, values[field.ID], errors[field.ID] != "")
				case "radio":
					@RenderRadioGroup(field, values[field.ID])
				default:
					<input name={ field.ID } value={ values[field.ID] }/>
			}
			<span class={ setShowClass("error-message", errors[field.ID] != "") }>{ errors[field.ID] }</span>
		</div>
	}
}

templ ContactPagePartialForm(page ContactPagePartialProps, state ContactFormState) {
	if page.FormTitle != "" {
		<h2>{ page.FormTitle }</h2>
	}
	<form
		class="form"
		hx-post="/contact"
		hx-trigger="submit"
		hx-target="this"
		hx-swap="outerHTML"
		hx-on:htmx:afterSwap="handleSuccessTimeout(this)"
		novalidate
	>
		if page.FormTitle != "" {
			<h2>{ page.FormTitle }</h2>
		}
		@RenderFormFields(page.FormFields, state.Values, state.Errors)
		<button type="submit" class="btn">
			<span class="btn-text">
				if state.Success {
					Отправлено
				} else {
					Отправить
				}
			</span>
			<span class={ setShowClass("w-4 h-4 send", !state.Success) }>
				@icons.ArrowRight("w-4 h-4 -rotate-45")
			</span>
			<span class={ setShowClass("w-4 h-4 success", state.Success) }>
				@icons.ThumbsUp("w-4 h-4")
			</span>
		</button>
	</form>
}
